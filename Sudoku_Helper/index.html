<html>
  <head>
    <link rel="stylesheet" href="style.css" type="text/css"/>
    <script src="jquery-3.4.1.min.js"></script>
    <script src="LineReader.js"></script>
    <script type="text/javascript">
      // CONSTANTS
      // some example sudokus to test various strategies
      const data_extreme1     = "000000050050793000430008006307000061000000000600002803900100032000654080000000000";
      const data_expert1      = "001004900009000800020100070800005000100700342007090000000007005900200000600000010";
      const data_xwing        = "000000004760010050090002081070050010000709000080030060240100070010090045900000000";
      const data_ywing        = "900040000000600031020000090000700020002935600070002000060000073510009000000080009";
      const data_zwing        = "090001700500200008000030200070004960200060005069700030008090000700003009003800040";
      const data_zwing2       = "600000000500900007820001030340209080000080000080307025050400092900005004000000003";
      const data_triples      = "070008029002000004854020000008374200000000000003261700000090612200000400130600070";
      const data_htriples     = "000000000231090000065003100008924000100050006000136700009300570000010843000000000";
      const data_nakedpairs   = "400000938032094100095300240370609004529001673604703090957008300003900400240030709";
      const data_hiddenpairs  = "720408030080000047401076802810739000000851000000264080209680413340000008168943275";
      const data_intersection = "016007803000800000070001060048000300600000002009000650060900020000002000904600510";
      const data_nakedquads   = "000030086000020000000008500371000094900000005400007600200700800030005000700004030";
      const data_swordfish    = "050030602642895317037020800023504700406000520571962483214000900760109234300240170";
      const data_swordfish2   = "020040069003806200060020000890500010000000000030001026000010070009604300270050090";
      const data_colors1      = "007083600039706800826419753640190387080367000073048060390870026764900138208630970";
      const data_finned1      = "900040000704080050080000100007600820620400000000000019000102000890700000000050003"; // current can't solve this (nor can andoku)
      const data_finned2      = "030605000800000030004010059000701006060000010500302000950020300070000008000107090"; // current can't solve this (nor can andoku)
      const data_default = undefined; // this one will be loaded automatically.

      // Flags to allow/disallow various solving strategies.
      // "simple" strategies
      const useNS = true; // naked singles
      const useHS = true; // hidden singles
      const useNP = true; // naked pairs
      const useHP = true; // hidden pairs
      const useNT = true; // naked triples
      const useHT = true; // hidden triples
      const useNQ = true; // naked quads
      const useIR = true; // intersection removal
      // "tough" strategies
      const useXW = true; // x-wings
      const useYW = true; // y-wings
      const useZW = true; // xyz-wings
      const useSF = true; // swordfish
      const useSC = true; // simple coloring
      const useFX = true; // finned x-wings 

      // how long to wait between applying solving steps.
      const stepDelay = 0;
      const flashDelay = Math.max(10, stepDelay*0.9);

      // GLOBALS
      // we store the sudoku in various ways simultaneously.
      var sudoku = [];
      var sudokuCols = [];
      var sudokuBoxes = [];
      var sudokuCellsByPos = [];      
      var newCellsConfirmed = []; // keep track of new cells as they are confirmed.

      var undoStack = [];

      // whether or not to print info on how the solve is achieved
      var logging = true;

      // input globals
      const SETNOTHING = 0;
      const SETFULL = 1;
      const SETCAND = 2;
      const SETCOLOR = 3;
      var inputState = SETNOTHING;
      var dragState  = undefined; // undefined = nothing. -1 = clear. 0-8 = set swatch.
      var inputNum   = undefined;

      // when the page is loaded, check if there is a query variable,
      // otherwise load the example from above.
      function onReady() {
        // prepare the board with the appropriate givens.
        var data = getQueryVariable("data");
        if (data) {
          initSudoku(data);
        } else {
          initSudoku(data_default);
        }

        // set up controls behaviour
        initControls();

        // show the board
        refresh();
      }

      // a 'confirm' button (td $'this') has been pressed
      var prevSelectedControl = undefined;
      function controlButton(ind, state) {
        if (prevSelectedControl) prevSelectedControl.removeClass("selected");
        if (inputState===state && inputNum===ind) {
          inputState = SETNOTHING;
          inputNum = undefined;
          refreshHighlights();
          return;
        }

        inputState = state;
        inputNum = ind;

        refreshHighlights();

        this.addClass("selected");
        prevSelectedControl = this;
      }

      function initControls() {
        $("table#confirm").find("td").each(function(ind){
          var that = $(this);
          that.off("click").click(function(){
            controlButton.call(that, ind, SETFULL);
          });
        });
        $("table#candidate").find("td").each(function(ind){
          var that = $(this);
          that.off("click").click(function(){
            controlButton.call(that, ind, SETCAND);
          });
        });
        $("table#swatches").find("td").each(function(ind){
          var that = $(this);
          that.attr("swatch",ind);
          that.off("click").click(function(){
            controlButton.call(that, ind, SETCOLOR);
          });
        });
        $(document).off("keydown").keydown(processKeys);
        $(document).off("mouseup").on("mouseup", function(){
          dragState = undefined;
        });
      }

      function processKeys(e) {
        var shift = e.shiftKey;
        var code  = e.code;
        if (code.startsWith("Digit")) {
          if (code === "Digit0") return true;
          var num = code.substring(5);
          if (shift)
            $("table#candidate").find("td:contains('"+num+"')").click();
          else
            $("table#confirm").find("td:contains('"+num+"')").click();
          return false;
        } else if (code==="Space") {
          $(".selected").click();
          return false;
        } else if (code==="KeyU") {
          flashButton("undobutton");
          undo();
        }
        return true;
      }

      // display the current state of the sudoku board.
      function refresh() {
        buildTable(sudoku);
        refreshHighlights();
      }

      // highlight some of the sudoku board
      function refreshHighlights() {
        if (inputState === SETNOTHING || inputState === SETCOLOR) {
          $("#tbl").find(".highlit").removeClass("highlit");
        }

        for (var r=0;r<sudoku.length; r++) {
          var row = sudoku[r];
          for (var c=0; c<row.length; c++) {
            var cell = row[c];
            if (inputState===SETFULL || inputState===SETCAND) {
              if (cell[inputNum] || cell.solved===inputNum) {
                cell.td.addClass("highlit");
              } else {
                cell.td.removeClass("highlit");
              }
            }
            if (cell.swatch===undefined)
              cell.td.attr('swatch', '');
            else
              cell.td.attr('swatch', cell.swatch);
          }
        }
      }

      // solve the sudoku as far as you can.
      // return the solution or "ERROR" or "INCOMPLETE".
      function completeSilently(data) {
        initSudokuData(data);
        while(makeSomeChange(false));
        if (checkErrors()) return "ERROR";
        if (getSolvedCount() < 81) return "INCOMPLETE";
        return getExportString();
      }

      // log to console iff "logging" is true.
      function consolelog() {
        logging && console.log(...arguments)
      }

      // apply one strategy. flash the associated button if "flash"=true.
      // try all strategies from the easiest to hardest. return true if
      // some progress was made.
      function makeSomeChange(flash=true) {
        if (newCellsConfirmed.length > 0 && clearAdjacents()) {
          // clearing cells adjacent to confirmed cells
          flash && flashButton("caButton");
          return true;
        } else if (useNS && nakedSingles()) {
          // naked singles
          flash && flashButton("nsButton");
          return true;
        } else if (useHS && hiddenSingles()) {
          // hidden singles
          flash && flashButton("hsButton");
          return true;
        } else if (useNP && nakedPairs()) {
          // naked pairs
          flash && flashButton("npButton");
          return true;
        } else if (useHP && hiddenPairs()) {
          // hidden pairs
          flash && flashButton("hpButton");
          consolelog("hidden pairs.");
          return true;
        } else if (useNT && nakedTriples()) {
          // naked triples
          flash && flashButton("ntButton");
          return true;
        } else if (useHT && hiddenTriples()) {
          // hidden triples
          flash && flashButton("htButton");
          return true;
        } else if (useIR && intersectionRemoval()) {
          // intersection removal
          flash && flashButton("irButton");
          return true;
        } else if (useNQ && nakedQuads()) {
          // hidden triples
          flash && flashButton("nqButton");
          return true;
        } else if (useXW && XWings()) {
          // x-wings
          flash && flashButton("xwButton");
          return true;
        } else if (useYW && YWings()) {
          // y-wings
          flash && flashButton("ywButton");
          return true;
        } else if (useZW && ZWings()) {
          // z-wings
          flash && flashButton("zwButton");
          return true;
        } else if (useSF && swordfish()) {
          // swordfish
          flash && flashButton("sfButton");
          return true;
        } else if (useFX && FinnedXWings()) {
          // finned x-wings
          flash && flashButton("fxButton");
          return true;
        } else if (useSC && simpleColors()) {
          // simple coloring
          flash && flashButton("scButton");
          return true;
        }
        return false;
      }
      
      // attempt to solve the whole sudoku, one step at a time.
      // includes a delay between solve steps.
      function autoSolve() {
        consolelog("Attempting to solve...");
        // make a single step, then wait before doing it again.
        var makestep = function() {
          if (makeSomeChange()) {
            refresh();
            setTimeout(makestep, stepDelay);
          } else {
            if (getSolvedCount() === 81) {
              consolelog("Sudoku is solved!");
            } else {
              consolelog("Could not make any further progress.");
            }
            if (checkErrors()) {
              consolelog("The current board has errors!");
            } else {
              consolelog("No errors were found in the current board.");
            }
          }
        }
        // start the first step
        makestep();
      }

      // check how many cells are solved.
      function getSolvedCount() {
        var count = 0;
        for (var r=0; r<9; r++)
          for (var c=0; c<9; c++)
            if (isSolved(sudoku[r][c]))
              count++;
        return count;
      }

      // clear candidates from all cells visible to newly confirmed cells.
      function clearAdjacents() {
        var changed = false;
        while(newCellsConfirmed.length > 0) {
          var cell = newCellsConfirmed.pop();
          if (isSolved(cell)) {
            changed = clearAfterConfirm(cell) || changed;
          } else {
            // somehow one of the cells in newCellsConfirmed isn't solved.
            // this should never happen - something is broken somewhere.
            consolelog("Something went very wrong with newCellsConfirmed.");
          }
        }
        if (changed) consolelog("Cleared candidates adjacent to confirmed cells.");
        return changed;
      }


      function findSingleCase(coll, val) {
        for (var i=0; i<9; i++)
          if (coll[i][val]) return coll[i];
        return false;
      }

      function hiddenSingles() {
        // var changedCells = [];
        // var changedCellLabels = [];
        var changedGroups = [];
        for (var i=0; i<9; i++) {
          var row = sudoku[i];
          var col = sudokuCols[i];
          var box = sudokuBoxes[i];
          var groups = [row, col, box];
          var counts = [[0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0]];

          // count each item's possibility count in each row/col/box
          for (var g=0; g<groups.length; g++) {
            var group = groups[g]; // row, col, or box
            for (var c=0; c<9; c++) {
              var cell = group[c];
              for (var v=0; v<9; v++) {
                if (cell[v]) counts[g][v]++;
              }
            }
          }

          // set any 1s to that cell
          for (var g=0; g<groups.length; g++) {
            var group = groups[g];
            for (var v=0; v<9; v++) {
              if (counts[g][v] === 1) {
                var cell = findSingleCase(group, v);
                confirmCell(cell, v);
                if (changedGroups.indexOf(group.groupName) === -1) {
                  changedGroups.push(group.groupName);
                }
              }
            }
          }
        }
        if (changedGroups.length > 0) {
          changedGroups.sort();
          consolelog("Hidden Singles found in " + changedGroups.join(", ") + ".");
          return true;
        }
        return false;
        // for (var i=0; i<changedCells.length; i++) {
        //   var group = changedCells[i][0];
        //   var cell  = changedCells[i][1];
        //   var v     = changedCells[i][2];
        //   consolelog("Hidden Single (" + (v+1) + ") found in " + group.groupName + ".");
        // }
        // return true;
      }


      function candidateCount(cell) {
        var n = 0;
        for (var i=0; i<9; i++) if (cell[i]) n++;
        return n;
      }

      function getSingleOption(cell) {
        for (var i=0; i<9; i++) if (cell[i]) return i;
        return -1;
      }
      // find naked singles

      function nakedSingles() {
        var singles = [];
        for (var r=0; r<9; r++) {
          for (var c=0; c<9; c++) {
            var cell = sudoku[r][c];
            if (candidateCount(cell) === 1) {
              singles.push(cell);
            }
          }
        }
        var changes = [];
        var changeVal = -1;
        for (var i=0; i<singles.length; i++) {
          var cell = singles[i];
          var v = getSingleOption(cell);
          confirmCell(cell, v);
          changes.push(cell.pos);
          changeVal = v;
        }
        if (changes.length === 1) {
          consolelog("Naked Single (" + (changeVal+1) + ") found at " + changes[0] + ".");
          return true;
        } else if (changes.length > 1) {
          consolelog("Naked Singles found at " + changes.join(", ") + ".");
          return true;
        }
        return false;
      }

      function moreThanLeft(group, n) {
        var count = 0;
        for (var i=0; i<9; i++)
          if (!isSolved(group[i]))
            count++;
        return (count > n);
      }

      function moreThanTwoLeft(group)   { return moreThanLeft(group, 2); }
      function moreThanThreeLeft(group) { return moreThanLeft(group, 3); }
      function moreThanFourLeft(group)  { return moreThanLeft(group, 4); }

      // the cells that have two candidates
      function getTwos(group) {
        var cells = [];
        for (var c=0; c<9; c++)
          if (candidateCount(group[c]) === 2)
            cells.push(group[c]);
        return cells;
      }

      // get the cells that have three candidates
      function getThrees(group) {
        var cells = [];
        for (var c=0; c<9; c++)
          if (candidateCount(group[c]) === 3)
            cells.push(group[c]);
        return cells;
      }

      // the values that are in two cells
      function getValTwos(group) {
        var vals = [];
        for (var v=0; v<9; v++)
          if (countPossibleCells(group, v) === 2)
          vals.push(v);
        return vals;
      }

      function getCandidates(cell) {
        var candidates = [];
        for (var v=0; v<9; v++) {
          if (cell[v])
            candidates.push(v);
        }
        return candidates;
      }

      function sameCandidates(cell1, cell2) {
        for (var v=0; v<9; v++) {
          if (cell1[v] ^ cell2[v])
            return false;
        }
        return true;
      }

      function everyGroupConcat(groupFunc) {
        var changes = [];
        var groupings = [sudoku, sudokuCols, sudokuBoxes];
        for (var g=0; g<3; g++) {
          var grouping = groupings[g];
          for (var i=0; i<9; i++) {
            var group = grouping[i];
            var ch = groupFunc(group);
            changes = changes.concat(ch);
          }
        }
        return changes;
      }

      function everyGroupPush(groupFunc) {
        var changes = [];
        var groupings = [sudoku, sudokuCols, sudokuBoxes];
        for (var g=0; g<3; g++) {
          var grouping = groupings[g];
          for (var i=0; i<9; i++) {
            var group = grouping[i];
            var ch = groupFunc(group);
            if (ch) changes.push(ch);
          }
        }
        return changes;
      }

      function everyRowCol(groupFunc) {
        var changed = false;
        var groupings = [sudoku, sudokuCols];
        for (var g=0; g<3; g++) {
          var grouping = groupings[g];
          for (var i=0; i<9; i++) {
            var group = grouping[i];
            changed = groupFunc(group) || changed;
          }
        }
        return changed;
      }

      function everyGroup(groupFunc) {
        var changed = false;
        var groupings = [sudoku, sudokuCols, sudokuBoxes];
        for (var g=0; g<3; g++) {
          var grouping = groupings[g];
          for (var i=0; i<9; i++) {
            var group = grouping[i];
            changed = groupFunc(group) || changed;
          }
        }
        return changed;
      }

      function nakedPairsGroup(group) {
        // changed = false;
        var changes = [];
        if (moreThanTwoLeft(group)){
          var twos = getTwos(group);
          for (var t1=0; t1<twos.length; t1++) {
            for (var t2=0; t2<t1; t2++) {
              if (sameCandidates(twos[t1], twos[t2])) {
                var [cand1, cand2] = getCandidates(twos[t1])
                if (clearNakedPair(group,cand1,cand2,twos[t1],twos[t2])) {
                  changes.push([group, cand1, cand2]);
                }
              }
            }
          }
        }
        return changes;
      }

      function nakedPairs() {
        var changes = everyGroupConcat(nakedPairsGroup);
        if (changes.length === 0) return false;
        for (var i=0; i<changes.length; i++) {
          var [group,cand1,cand2] = changes[i];
          consolelog("Naked Pair " + vstr2(cand1,cand2) + " found in " + group.groupName + ".");
        }
        return true;
      }

      function combinedCandidateCount(cell1, cell2) {
        var count=0;
        for (var v=0; v<9; v++) {
          if (cell1[v] || cell2[v]) count++;
        }
        return count;
      }

      function combinedCandidateCount3(cell1, cell2, cell3) {
        var count=0;
        for (var v=0; v<9; v++) {
          if (cell1[v] || cell2[v] || cell3[v]) count++;
        }
        return count;
      }

      function combinedCandidateCount4(cell1, cell2, cell3, cell4) {
        var count=0;
        for (var v=0; v<9; v++) {
          if (cell1[v] || cell2[v] || cell3[v] || cell4[v]) count++;
        }
        return count;
      }

      function combinedCandidates(cell1, cell2) {
        var candidates = [];
        for (var v=0; v<9; v++) {
          if (cell1[v] || cell2[v]) {
            candidates.push(v);
          }
        }
        return candidates;
      }

      function combinedCandidates3(cell1, cell2, cell3) {
        var candidates = [];
        for (var v=0; v<9; v++) {
          if (cell1[v] || cell2[v] || cell3[v]) {
            candidates.push(v);
          }
        }
        return candidates;
      }

      function combinedCandidates4(cell1, cell2, cell3, cell4) {
        var candidates = [];
        for (var v=0; v<9; v++) {
          if (cell1[v] || cell2[v] || cell3[v] || cell4[v]) {
            candidates.push(v);
          }
        }
        return candidates;
      }

      function clearNakedTriple(group, i1, i2, i3, cand1, cand2, cand3) {
        var changed = false;
        for (var c=0; c<9; c++) {
          if (c!==i1 && c!==i2 && c!==i3) {
            var cell = group[c];
            changed = changed || cell[cand1] || cell[cand2] || cell[cand3];
            cell[cand1] = false;
            cell[cand2] = false;
            cell[cand3] = false;
          }
        }
        return changed;
      }

      function clearNakedQuad(group, i1, i2, i3, i4, cand1, cand2, cand3, cand4) {
        var changed = false;
        for (var c=0; c<9; c++) {
          if (c!==i1 && c!==i2 && c!==i3 && c!==i4) {
            var cell = group[c];
            changed = changed || cell[cand1] || cell[cand2] || cell[cand3] || cell[cand4];
            cell[cand1] = false;
            cell[cand2] = false;
            cell[cand3] = false;
            cell[cand4] = false;
          }
        }
        return changed;
      }

      function nakedTriplesGroup(group) {
        if (!moreThanThreeLeft(group)) return false;

        //get the indexes of items with three or fewer options
        var threeOrLessInds = [];
        for (var c=0; c<9; c++) {
          if ( (!isSolved(group[c])) && candidateCount(group[c]) <= 3) {
            threeOrLessInds.push(c);
          }
        }

        // there needs to be at least three
        if (threeOrLessInds.length < 3) return false;

        // find if any three of these cells contain three candidates in total
        for (var i1=0; i1<threeOrLessInds.length; i1++) {
          var ii1 = threeOrLessInds[i1];
          for (var i2=0; i2<i1; i2++) {
            var ii2 = threeOrLessInds[i2];
            if (combinedCandidateCount(group[ii1], group[ii2]) === 3) {
              // at this point we have two cells whose combined cell count is 3.
              // if we can find a third that still holds this, we are in business.
              for (var i3=i1+1; i3<threeOrLessInds.length; i3++) {
                var ii3 = threeOrLessInds[i3];
                if (combinedCandidateCount3(group[ii1], group[ii2], group[ii3]) === 3) {
                  var cands = combinedCandidates3(group[ii1], group[ii2], group[ii3]);
                  if (clearNakedTriple(group, ii1,ii2,ii3, cands[0], cands[1], cands[2])) {
                    consolelog("Naked Triple " + vstr3(...cands) + " found in " + group.groupName + ".");
                    return true;
                  }
                }
              }
            }
          }
        }
      }

      function nakedTriples() {
        return everyGroup(nakedTriplesGroup);
      }

      function nakedQuadsGroup(group) {
        if (!moreThanFourLeft(group)) return false;

        //get the indexes of items with four or fewer options
        var fourOrLessInds = [];
        for (var c=0; c<9; c++) {
          if ( (!isSolved(group[c])) && candidateCount(group[c]) <= 4) {
            fourOrLessInds.push(c);
          }
        }

        // there needs to be at least four
        if (fourOrLessInds.length < 4) return false;

        // find out if any four of these cells contain four candidates in total
        for (var i1=0; i1<fourOrLessInds.length; i1++) {
          var c1 = fourOrLessInds[i1];
          for (var i2=i1+1; i2<fourOrLessInds.length; i2++) {
            var c2 = fourOrLessInds[i2];
            var candCount_c1c2 = combinedCandidateCount(group[c1], group[c2]);
            if (candCount_c1c2 === 3 || candCount_c1c2 === 4) {
              // at this point we have two cells with a combined candidate count of three or four.
              for (var i3=i2+1; i3<fourOrLessInds.length; i3++) {
                var c3 = fourOrLessInds[i3];
                var candCount_c1c2c3 = combinedCandidateCount3(group[c1], group[c2], group[c3]);
                if (candCount_c1c2c3 === 4) {
                  // at this point we have three cells with a combined candidate count of four.
                  for (var i4=i3+1; i4<fourOrLessInds.length; i4++) {
                    var c4 = fourOrLessInds[i4];
                    var candCount_all = combinedCandidateCount4(group[c1], group[c2], group[c3], group[c4]);
                    if (candCount_all === 4) {
                      // we have four cells that can only be four values. this is a naked quad.
                      var candidates = combinedCandidates4(group[c1], group[c2], group[c3], group[c4]);
                      var [cand1,cand2,cand3,cand4] = candidates;
                      if (clearNakedQuad(group, c1, c2, c3, c4, cand1, cand2, cand3, cand4)) {
                        consolelog("Naked Quad " + vstr4(cand1,cand2,cand3,cand4) + " found in " + group.groupName + ".");
                        return true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return false;
      }

      function nakedQuads() {
        return everyGroup(nakedQuadsGroup);
      }

      function mapCount(map) {
        var count = 0;
        for (var i=0; i<map.length; i++)
          if (map.charAt(i) === "1") count++;
        return count;
      }

      function mapOr(map1, map2) {
        var out = "";
        for (var i=0; i<map1.length; i++) {
          if (map1.charAt(i)==="1" || map2.charAt(i)==="1")
            out = out + "1";
          else
            out = out + "0";
        }
        return out;
      }

      function mapOrCount(map1, map2) {
        var count = 0;
        for (var i=0; i<map1.length; i++)
          if (map1.charAt(i)==="1" || map2.charAt(i)==="1") count++;
        return count;
      }

      function mapOrCount3(map1, map2, map3) {
        var count = 0;
        for (var i=0; i<map1.length; i++)
          if (map1.charAt(i)==="1" || map2.charAt(i)==="1" || map3.charAt(i)==="1") count++;
        return count;
      }

      function clearHiddenTriple(group, v1, v2, v3) {
        var changed = false;
        for (var c=0; c<9; c++) {
          var cell = group[c];
          if ((!isSolved(cell)) && (cell[v1] || cell[v2] || cell[v2])) {
            for (var v=0; v<9; v++) {
              if (v!==v1 && v!==v2 && v!==v3) {
                changed = changed || cell[v];
                cell[v] = false;
              }
            }
          }
        }
        return changed;
      }

      function hiddenTripleGroup(group) {
        // we need four or more open cells for this to work
        if (!moreThanThreeLeft(group)) return false;

        //get the values that are found in three or fewer cells
        var vals = [];
        for (var v=0; v<9; v++) {
          var possibleCells = countPossibleCells(group, v);
          if (possibleCells <= 3 && possibleCells > 0)
            vals.push(v);
        }

        // get group maps for all values
        var maps = [];
        for (var vi=0; vi<vals.length; vi++) {
          maps.push(getGroupMap(group, vals[vi]));
        }

        // check if any three overlap to three cells
        for (var i1=0; i1<maps.length; i1++) {
          for (var i2=0; i2<i1; i2++) {
            if (mapOrCount(maps[i1], maps[i2]) === 3) {
              for (var i3=i1+1; i3<maps.length; i3++) {
                // consolelog(maps, i1, i2, i3);
                if (mapOrCount3(maps[i1], maps[i2], maps[i3]) === 3) {
                  if (clearHiddenTriple(group, vals[i1], vals[i2], vals[i3])){
                    consolelog("Hidden Triple " + vstr3(vals[i2],vals[i1],vals[i3]) + " found in " + group.groupName + ".");
                    return true;
                  }
                }
              }
            }
          }
        }
      }

      function vstr2(a, b) {
        return "(" + (a+1) + ", " + (b+1) + ")";
      }

      function vstr3(a, b, c) {
        return "(" + (a+1) + ", " + (b+1) + ", " + (c+1) + ")";
      }

      function vstr4(a, b, c, d) {
        return "(" + (a+1) + ", " + (b+1) + ", " + (c+1) + ", " + (d+1) + ")";
      }

      function comand3(a, b, c) {
        return "" + (a+1) + ", " + (b+1) + ", and " + (c+1);
      }

      function hiddenTriples() {
        return everyGroup(hiddenTripleGroup);
      }

      function countPossibleCells(group, v) {
        var count = 0;
        for (var c=0; c<9; c++) {
          var cell = group[c];
          if (!isSolved(cell)) {
            if (cell[v])
              count++;
          }
        }
        return count;
      }

      function getCellMap(cell) {
        if (isSolved(cell)) return "000000000";
        var map = "";
        for (var v=0; v<9; v++) {
          if (cell[v])
            map = map + "1";
          else
            map = map + "0";
        }
        return map;
      }

      function getGroupMap(group, v) {
        var map = "";
        for (var c=0; c<9; c++) {
          var cell = group[c];
          if (isSolved(cell)) {
            map = map + "0";
          } else {
            if (cell[v])
              map = map + "1";
            else
              map = map + "0";
          }
        }
        return map;
      }

      function listOfNine(x) {
        return [x,x,x,x,x,x,x,x,x];
      }
      function listOf(x, n) {
        var out = [];
        for (var i=0; i<n; i++)
          out.push(x);
        return out;
      }

      function clearHiddenPair(group, v1, v2, map) {
        var changed = false;
        for (var c=0; c<9; c++) {
          if (map.charAt(c) === "1") {
            var cell = group[c];
            for (var v=0; v<9; v++) {
              if (v !== v1 && v !== v2) {
                if (cell[v]) {
                  changed = true;
                  cell[v] = false;
                }
              }
            }
          }
        }
        return changed;
      }

      
      function hiddenPairsGroup(group) {
        if (!moreThanTwoLeft(group)) return []
        var vals = getValTwos(group); // the values that are only in two cells
        var maps = [];
        for (var i1=0; i1<vals.length; i1++) {
          var v1 = vals[i1];
          maps.push(getGroupMap(group, v1));
          for (var i2=0; i2<i1; i2++) {
            var v2 = vals[i2];
            if (maps[i2] === maps[i1]) {
              if (clearHiddenPair(group, v2, v1, maps[i1])) {
                return [[group, v2, v1]];
              }
            }
          }
        }
        return [];
      }

      function hiddenPairs() {
        var changes = everyGroupConcat(hiddenPairsGroup);
        if (changes.length === 0) return false;
        for (var i=0; i<changes.length; i++) {
          var [group,v1,v2] = changes[i];
          consolelog("Hidden Pair " + vstr2(v1,v2) + " found in " + group.groupName + ".");
        }
      }


      String.prototype.nthIndexOf = function(pattern, n) {
        var i = -1;
        while (n-- && i++ < this.length) {
          i = this.indexOf(pattern, i);
          if (i < 0) break;
        }
        return i;
      }

      function getFirst1(str) {
        for (var i=0; i<str.length; i++) {
          if (str.charAt(i)==="1") return i;
        }
        return -1;
      }
      function getSecond1(str) {
        var passed1 = false;
        for (var i=0; i<str.length; i++) {
          if (str.charAt(i)==="1") {
            if (passed1) {
              return i;
            } else {
              passed1 = true;
            }
          }
        }
        return -1;
      }
      function getThird1(str) {
        var onesfound = 0;
        for (var i=0; i<str.length; i++) {
          
        }
      }

      function clearXWing(groups, v, g1, g2, y1, y2) {
        var changed = false;
        for (var g=0; g<9; g++) {
          if (g!==g1 && g!==g2) {
            changed = changed || groups[g][y1][v] || groups[g][y2][v];
            groups[g][y1][v] = false;
            groups[g][y2][v] = false;
          }
        }
        return changed;
      }

      function XWingsAux(groups, groupType) {
        for (var v=0; v<9; v++) {
          // var maps = listOfNine("000000000");
          var groupInds = [];
          var maps = [];
          for (var g=0; g<9; g++) {
            var group = groups[g];
            if (countPossibleCells(group, v) === 2) {
              groupInds.push(g);
              var map = getGroupMap(group, v);
              maps.push(map);
              for (var g2i=0; g2i<groupInds.length-1; g2i++) { //don't compare with yourself
                if (maps[g2i] === map) {
                  var y1 = getFirst1(map);
                  var y2 = getSecond1(map);
                  var g2 = groupInds[g2i];
                  if (clearXWing(groups, v, g2, g, y1, y2)) {
                    consolelog("X-Wing on value " + (v+1) + " found on " + groupType + " " + (g2+1) + " and " + (g+1) + ".");
                    return true;
                  }
                }
              }
            }
          }
        }
        return false;
      }

      function XWings() {
        return XWingsAux(sudoku, "rows") || XWingsAux(sudokuCols, "cols");
      }


      function clearFinnedXWing(v, y1, y2, x, groupType) {
        var group = sudoku[x];
        if (groupType === 'rows')
          group = sudokuCols[x];
        
        var changed = false;
        var clearBlock = blockInd(y2);
        for (var i=clearBlock*3; i<(clearBlock+1)*3; i++) {
          if (i!==y1 && i!==y2) {
            changed = group[i][v] || changed;
            group[i][v] = false;
          }
        }
        return changed;
      }


      function blockInd(cellInd) {
        if (cellInd<3) return 0;
        if (cellInd<6) return 1;
        return 2;
      }

      // input: list of nine 0s and 1s representing candidate presence.
      // twoMap has exactly two 1s and moreMap has 3 or 4.
      function FinnedMapMatch(twoMap, moreMap) {
        var y1 = getFirst1(twoMap);
        var y2 = getSecond1(twoMap);
        var b1 = blockInd(y1);
        var b2 = blockInd(y2);

        // make sure moreMap includes the x-wing
        if (moreMap[y1] !== '1') return false;
        if (moreMap[y2] !== '1') return false;

        if (b1===b2) { // in the same block
          for (var i=0; i<9; i++) {
            if (moreMap[i]==='1' && blockInd(i) !== b1)
              // there are candidates that don't share a block with an X corner
              return false;
          }
          return (b1+1);
        } else {
          var withB1 = false;
          var withB2 = false;
          for (var i=0; i<9; i++) {
            if (i !== y1 && i !== y2 && moreMap[i]==='1') {
              var ib = blockInd(i);
              if      (ib === b1) withB1 = true;
              else if (ib === b2) withB2 = true;
              else                return false; // candidates with neither blocks
            }
          }
          if (withB1 &&  withB2) return false; // candidates with both blocks
          // return which one index we start with
          if (withB1) return y1 + 1;
          if (withB2) return y2 + 1;
          return true;
        }
      }

      function FinnedXWingsAux(groups, groupType) {
        for (var v=0; v<9; v++) { // values
          var groupInds = [];
          var otherGroupInds = [];
          var maps = [];
          var otherMaps = [];
          // map out groups
          for (var g=0; g<9; g++) {
            var group = groups[g];
            var cellCount = countPossibleCells(group, v);
            if (cellCount === 2) {
              groupInds.push(g);
              maps.push(getGroupMap(group, v));
            } else if (cellCount === 3 || cellCount === 4) {
              otherGroupInds.push(g);
              otherMaps.push(getGroupMap(group, v));
            }
          }
          // at this point groupInds contains the group index of every group with exactly 2 candidates
          // also 'maps' contains the string map (0s and 1s) of value 'v' for that group
          for (var gi=0; gi<groupInds.length; gi++) {
            for (var ogi=0; ogi<otherGroupInds.length; ogi++) {
              var twoMap = maps[gi];
              var moreMap = otherMaps[ogi];
              var finMatch = FinnedMapMatch(twoMap, moreMap);
              if (finMatch) {
                // we have a finned x-wing
                var twoInd = groupInds[gi];
                var moreInd = otherGroupInds[ogi];
                if (clearFinnedXWing(v, twoInd, moreInd, (finMatch-1), groupType)) {
                  console.log("Finned X-Wing (" + (v+1) + ") found on " + groupType + " " + (twoInd+1) + " and (fin) " + (moreInd+1));
                  return true;
                }
              }
            }
          }
        }
        return false;
      }

      function FinnedXWings() {
        return FinnedXWingsAux(sudoku, "rows") || FinnedXWingsAux(sudokuCols, "cols");
      }


      function candidateXOR(cell1, cell2) {
        var out = [];
        for (var v=0; v<9; v++)
          if (cell1[v] !== cell2[v])
            out.push(v);
        return out;
      }

      function findAdjacentByCands(cell, cands, groupType) {

      }

      function cellHasExactlyCands(cell, cands) {
        for (var v=0; v<9; v++) {
          if (cands.indexOf(v)===-1) {
            if (cell[v]) return false;
          } else {
            if (!cell[v]) return false;
          }
        }
        return true;
      }

      function findByCands(group, cands) {
        for (var c=0; c<9; c++) {
          var cell = group[c];
          if (cellHasExactlyCands(cell, cands)) {
            return cell;
          }
        }
        return false;
      }

      function boxRow(box) {
        if (box===0 || box===1 || box===2) return 0;
        if (box===3 || box===4 || box===5) return 1;
        if (box===6 || box===7 || box===8) return 2;
        return -1;
      }
      function boxCol(box) {
        if (box===0 || box===3 || box===6) return 0;
        if (box===1 || box===4 || box===7) return 1;
        if (box===2 || box===5 || box===8) return 2;
        return -1;
      }

      function YWcoVisibleCells(cell1, cell2) {
        var cells = [];
        if (boxRow(cell1.box)===boxRow(cell2.box)) {
          // wings share a box row
          var box1 = sudokuBoxes[cell1.box];
          var box2 = sudokuBoxes[cell2.box];
          for (var i=0; i<9; i++) {
            if (box1[i].row === cell2.row && box1[i]!==cell2 && !isSolved(box1[i])) cells.push(box1[i]);
            if (box2[i].row === cell1.row && box2[i]!==cell1 && !isSolved(box2[i])) cells.push(box2[i]);
          }
        } else if (boxCol(cell1.box)===boxCol(cell2.box)) {
          // wings share a box col
          var box1 = sudokuBoxes[cell1.box];
          var box2 = sudokuBoxes[cell2.box];
          for (var i=0; i<9; i++) {
            if (box1[i].col === cell2.col && box1[i]!==cell2 && !isSolved(box1[i])) cells.push(box1[i]);
            if (box2[i].col === cell1.col && box2[i]!==cell1 && !isSolved(box2[i])) cells.push(box2[i]);
          }
        } else {
          // no common box row or col. must only be two shared cells (one will be the pivot)
          var corner1 = sudoku[cell1.row][cell2.col];
          var corner2 = sudoku[cell2.row][cell1.col];
          if (!isSolved(corner1)) cells.push(corner1);
          if (!isSolved(corner2)) cells.push(corner2);
        }
        return cells;
      }

      function commonCandidate(cell1, cell2) {
        // returns ONE common candidate between cell1 and cell2
        // returns -1 if there are none.
        for (var v=0; v<9; v++) {
          if (cell1[v] && cell2[v]) return v;
        }
        return -1;
      }

      function clearYWing(pivot, wing1, wing2) {
        var changed = false;
        var covisible = YWcoVisibleCells(wing1, wing2);
        var v = commonCandidate(wing1, wing2);
        for (var i=0; i<covisible.length; i++) {
          var cell = covisible[i];
          if (cell !== pivot) {
            changed = changed || cell[v];
            cell[v] = false;
          }
        }
        if (changed) {
          var cands = combinedCandidates3(pivot, wing1, wing2);
          consolelog("Y-Wing "+vstr3(...cands)+" pivoted on " + pivot.pos + " with wings at " + wing1.pos + " and " + wing2.pos + ".");
          return true;
        }
        return false;
      }

      function YWingRC(group) {
        // consolelog("checking for y-wings...");
        // there needs to be at least three open spots in this group
        if (moreThanTwoLeft(group)){
          // all members must have two candidates
          var twos = getTwos(group);
          for (var t1=0; t1<twos.length; t1++) {
            for (var t2=t1+1; t2<twos.length; t2++) {
              var cell1 = twos[t1];
              var cell2 = twos[t2];
              if (combinedCandidateCount(cell1, cell2) === 3) {
                // two 2-cells in this group can be three candidates together
                var finalCellCands = candidateXOR(cell1, cell2);

                // if they are not in the same box, search the boxes of both ends for the final cell
                if (cell1.box !== cell2.box) {
                  var wing2 = findByCands(sudokuBoxes[cell1.box], finalCellCands);
                  if (wing2 && wing2.row!==cell2.row && wing2.col!==cell2.col) {
                    var pivot = cell1; var wing1 = cell2;
                    if (clearYWing(pivot, wing1, wing2)) return true;
                  } else {
                    wing2 = findByCands(sudokuBoxes[cell2.box], finalCellCands);
                    if (wing2 && wing2.row!==cell1.row && wing2.col!==cell1.col) {
                      var pivot = cell2; var wing1 = cell1;
                      if (clearYWing(pivot, wing1, wing2)) return true;
                    }
                  }
                }

                // search the perpendicular group for the final cell
                if (group.groupType === "row") {
                  var wing2 = findByCands(sudokuCols[cell1.col], finalCellCands);
                  if (wing2) {
                    var pivot = cell1; var wing1 = cell2;
                    if (clearYWing(pivot, wing1, wing2)) return true;
                  } else {
                    wing2 = findByCands(sudokuCols[cell2.col], finalCellCands);
                    if (wing2) {
                      var pivot = cell2; var wing1 = cell1;
                      if (clearYWing(pivot, wing1, wing2)) return true;
                    }
                  }
                } else if (group.groupType === "col") {
                  var wing2 = findByCands(sudoku[cell1.row], finalCellCands);
                  if (wing2) {
                    var pivot = cell1; var wing1 = cell2;
                    if (clearYWing(pivot, wing1, wing2)) return true;
                  } else {
                    wing2 = findByCands(sudoku[cell2.row], finalCellCands);
                    if (wing2) {
                      var pivot = cell2; var wing1 = cell1;
                      if (clearYWing(pivot, wing1, wing2)) return true;
                    }
                  }
                }
              }
            }
          }
        }
        return false;
      }

      function YWings() {
        for (var g=0; g<9; g++) {
          if (YWingRC(sudoku[g]))     return true;
          if (YWingRC(sudokuCols[g])) return true;
        }
        return false;
      }

      function clearZWing(rowcol, z, box, pivot) {
        var changed = false;
        for (var c=0; c<9; c++) {
          var cell = rowcol[c];
          if (cell.box === box && !sameCell(cell, pivot)) {
            changed = changed || cell[z];
            cell[z] = false;
          }
        }
        return changed;
      }

      function ZWingsBox(box) {
        // get the cells in this box with two and three candidates
        var twos   = getTwos(box);
        var threes = getThrees(box);

        if (twos.length   === 0) return false;
        if (threes.length === 0) return false;
        
        for (var i2=0; i2<twos.length; i2++) {
          for (var i3=0; i3<threes.length; i3++) {
            if (combinedCandidateCount(twos[i2], threes[i3]) === 3) {
              // this box has an XY and an XYZ
              var cellXYZ = threes[i3];
              var cellXZ  = twos[i2];

              // look for the YZ cell in the pivot's column
              if (cellXZ.col !== cellXYZ.col) for (var c=0; c<9; c++) {
                var cellYZ = sudokuCols[cellXYZ.col][c];
                if (cellYZ.box !== cellXYZ.box
                 && candidateCount(cellYZ) === 2
                 && combinedCandidateCount(cellYZ, cellXYZ) === 3
                 && !sameCandidates(cellYZ, cellXZ)) {
                  // we have a XYZ-wing
                  var Z = commonCandidate(cellXZ, cellYZ);
                  if (clearZWing(sudokuCols[cellXYZ.col], Z, cellXYZ.box, cellXYZ)) {
                    var cands = getCandidates(cellXYZ);
                    consolelog("XYZ-Wing "+vstr3(...cands)+" pivoted on "+cellXYZ.pos+" with wings at "+cellXZ.pos+" and "+cellYZ.pos+".");
                    return true;
                  } else {
                    break; // there can't be another YZ - that would be a naked pair/triple
                  }
                }
              }

              // look for the YZ cell in the pivot's row
              if (cellXZ.row !== cellXYZ.row) for (var c=0; c<9; c++) {
                var cellYZ = sudoku[cellXYZ.row][c];
                if (cellYZ.box !== cellXYZ.box
                 && candidateCount(cellYZ) === 2
                 && combinedCandidateCount(cellYZ, cellXYZ) === 3
                 && !sameCandidates(cellYZ, cellXZ)) {
                  // we have a XYZ-wing
                  var Z = commonCandidate(cellXZ, cellYZ);
                  if (clearZWing(sudoku[cellXYZ.row], Z, cellXYZ.box, cellXYZ)) {
                    var cands = getCandidates(cellXYZ);
                    consolelog("XYZ-Wing "+vstr3(...cands)+" pivoted on "+cellXYZ.pos+" with wings at "+cellXZ.pos+" and "+cellYZ.pos+".");
                    return true;
                  } else {
                    break; // there can't be another YZ - that would be a naked pair/triple
                  }
                }
              }
            }
          }
        }
        return false;
      }

      function ZWings() {
        for (var b=0; b<9; b++)
          if (ZWingsBox(sudokuBoxes[b])) return true;
        return false;
      }

      function clearSwordfish(groups, v, g1, g2, g3, y1, y2, y3) {
        var changed = false;
        for (var g=0; g<9; g++) {
          if (g!==g1 && g!==g2 && g!==g3) {
            changed = changed || groups[g][y1][v] || groups[g][y2][v] || groups[g][y3][v];
            groups[g][y1][v] = false;
            groups[g][y2][v] = false;
            groups[g][y3][v] = false;
          }
        }
        return changed;
      }

      function swordfishAux(groups, groupType) {
        // consider values separately
        for (var v=0; v<9; v++) {
          var groupInds = [];
          var maps = [];
          // consider each group (row or col)
          for (var g=0; g<9; g++) {
            var group = groups[g];
            // we only care about groups with two or three candidates for v
            var groupCellCount = countPossibleCells(group, v);
            if (groupCellCount === 3 || groupCellCount === 2) {
              groupInds.push(g);
              // get a candidate map for v for this group
              var map = getGroupMap(group, v);
              // rememeber it for later
              maps.push(map);
              // look through all the previous maps to see if there are matches
              for (var g2i=0; g2i<groupInds.length-1; g2i++) {
                if (mapOrCount(map, maps[g2i]) === 3) {
                  // there are two groups that have three options together. find a third.
                  var map12 = mapOr(map, maps[g2i]); // save the first two for later
                  for (var g3i=g2i+1; g3i<groupInds.length-1; g3i++) {
                    if (mapOrCount(map12, maps[g3i]) === 3) {
                      // there are three groups that have three options together.
                      // this is a swordfish.
                      var g2 = groupInds[g2i];
                      var g3 = groupInds[g3i];
                      var y1 = map12.nthIndexOf("1",1);
                      var y2 = map12.nthIndexOf("1",2);
                      var y3 = map12.nthIndexOf("1",3);
                      if (clearSwordfish(groups,v,g,g2,g3,y1,y2,y3)) {
                        consolelog("Swordfish on value "+(v+1)+" found on "+groupType+" "+comand3(g2,g3,g)+".");
                        return true;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return false;
      }

      function swordfish() {
        return swordfishAux(sudoku, "rows") || swordfishAux(sudokuCols, "cols");
      }

      function getOnlyTwoCells(group, v) {
        var out = [];
        for (var c=0; c<9; c++) {
          if (group[c][v]) {
            out.push(group[c]);
          }
        }
        if (out.length === 2)
          return out;
        return false;
      }


      function placeLink(graph, from, to) {
          if (graph[from] === undefined) {
            graph[from] = [to];
          } else if(graph[from].indexOf(to)===-1) {
            graph[from].push(to);
          }
      }

      function otherClr(clr) {
        if (clr==='red')   return 'green';
        if (clr==='green') return 'red';
        return 'whatthefuck';
      }

      function fillStarting(links, colors, start, color) {
        // this point has already been touched. do nothing.
        if (colors[start]) return;

        // set the color of this node.
        colors[start] = color;
        
        // color from each of the adjacent nodes.
        // start with the 'other' color.
        var adjs = links[start];
        var nextColor = otherClr(color);
        for (var i=0; i<adjs.length; i++) {
          fillStarting(links, colors, adjs[i], nextColor);
        }
      }

      function getRedsGreens(links, colors, start) {
        var grns = [];
        var reds = [];

        function step(node) {
          // disregard nodes we have already looked at
          if (grns.indexOf(node)>=0) return;
          if (reds.indexOf(node)>=0) return;

          // put this noe in the right box
          if (colors[node]==='red') {
            reds.push(node);
          } else if (colors[node]==='green') {
            grns.push(node);
          }

          // look at all adjacent nodes
          for (var i=0; i<links[node].length; i++) {
            step(links[node][i]);
          }
        }

        // step through this graph
        step(start);

        return [reds,grns];
      }

      function colorOccursTwiceInOneGroup(labels) {
        var rows = []; var cols = []; var boxes = [];
        for (var i=0; i<labels.length; i++) {
          var cell = sudokuCellsByPos[labels[i]];
          if (rows[cell.row] || cols[cell.col] || boxes[cell.box]) {
            if (rows[cell.row]) {
              return [sudoku[cell.row], rows[cell.row], cell];
            } else if (cols[cell.col]) {
              return [sudokuCols[cell.col], cols[cell.col], cell];
            } else if (boxes[cell.box]) {
              return [sudokuBoxes[cell.box], boxes[cell.box], cell];
            }
          }
          rows[cell.row] = cols[cell.col] = boxes[cell.box] = cell;
        }
        return [false];
      }

      function confirmColor(labels, v) {
        for (var i=0; i<labels.length; i++)
          confirmCell(sudokuCellsByPos[labels[i]], v);
      }

      function simpleColorsVal(v) {
        var links  = [];
        var colors = [];

        // get all the strong links for this value
        var strongLinks = everyGroupPush(g => getOnlyTwoCells(g, v));

        // there needs to be at least three links to solve anything
        if (strongLinks.length < 3) return false;

        // build a set of links between nodes (this represents the graph)
        for (var i=0; i<strongLinks.length; i++) {
          placeLink(links, strongLinks[i][0].pos, strongLinks[i][1].pos);
          placeLink(links, strongLinks[i][1].pos, strongLinks[i][0].pos);
        }

        // get a list of separated (and now colored) graphs
        var graphStarts = [];
        for (var i=0; i<strongLinks.length; i++) {
          var node = strongLinks[i][0].pos;
          if (colors[node] === undefined) {
            graphStarts.push(node); // this node is uncolored. it is the start of a new graph.
            fillStarting(links, colors, node, 'red');
          }
        }

        // take a look at each graph
        for (var i=0; i<graphStarts.length; i++) {
          var [reds,grns] = getRedsGreens(links, colors, graphStarts[i]);
          // need at least four points to be a useful graph
          if (reds.length + grns.length > 3) {
            // check if any color occurs twice in a group
            var [group, cell1, cell2] = colorOccursTwiceInOneGroup(reds);
            var colorWithConflict = 'red';
            if (!group) {
              [group, cell1, cell2] = colorOccursTwiceInOneGroup(grns);
              colorWithConflict = 'green';
            }
            if (group) {
              // there is a conflict! the conflicted color is "colorWithConflict"
              if (colorWithConflict === 'red')   confirmColor(grns, v);
              if (colorWithConflict === 'green') confirmColor(reds, v);
              // report the logic that was followed.
              var path = getPathBetweenCells(links,cell1.pos,cell2.pos).join("->");
              consolelog("Found simple colors chain on value "+(v+1)+". "+path+" starts and ends with odds in "+group.groupName+". Confirming evens.");
              return true;
            } else {
              // there are no "two reds in one group" style conflicts.
              // look for co-visible nodes.
              var numChanged = findCovisibleToColors(v,reds,grns);
              if (numChanged>0) {
                console.log("Simple colors chain found on value "+(v+1)+", removing candidates from "+numChanged+" cells. Red: "+reds.join(",")+". Green: "+grns.join(",")+".");
                return true;
              }
            }
          }
        }
        return false;
      }

      function coVisibleCells(cellA, cellB) {
        var cells = [];

        function maybeCell(cell) {
          if (!isSolved(cell) && cell!==cellA && cell!==cellB)
            cells.push(cell);
        }

        if (cellA.box===cellB.box) {
          // cells are in the same box
          var box = sudokuBoxes[cellA.box];
          for (var c=0; c<9; c++) {
            maybeCell(box[c]);
          }
        }

        if (cellA.row===cellB.row) {
          // cells are in the same row
          var row = sudoku[cellA.row];
          for (var c=0; c<9; c++) {
            maybeCell(row[c]);
          }
        } else if(boxRow(cellA.box)===boxRow(cellB.box) && cellA.box!==cellB.box) {
          // cells are in the same 'box row' but not in the same box
          var boxA = sudokuBoxes[cellA.box];
          var boxB = sudokuBoxes[cellB.box];
          for (var c=0; c<9; c++) {
            var cellA2 = boxA[c];
            var cellB2 = boxB[c];
            if (cellA2.row===cellB.row)
              maybeCell(cellA2);
            if (cellB2.row===cellA.row)
              maybeCell(cellB2);
          }
        }

        if (cellA.col===cellB.col) {
          // cells are in the same column
          var col = sudokuCols[cellA.col];
          for (var c=0; c<9; c++) {
            maybeCell(col[c]);
          }
        } else if(boxCol(cellA.box)===boxCol(cellB.box) && cellA.box!==cellB.box) {
          // cells are in the same 'box col' but not in the same box
          var boxA = sudokuBoxes[cellA.box];
          var boxB = sudokuBoxes[cellB.box];
          for (var c=0; c<9; c++) {
            var cellA2 = boxA[c];
            var cellB2 = boxB[c];
            if (cellA2.col===cellB.col)
              maybeCell(cellA2);
            if (cellB2.col===cellA.col)
              maybeCell(cellB2);
          }
        }

        // get the opposite corner cells
        maybeCell(sudoku[cellA.row][cellB.col]);
        maybeCell(sudoku[cellB.row][cellA.col]);

        return cells;
      }

      function findCovisibleToColors(v,reds,grns) {
        var changes = 0;
        for (var r=0; r<reds.length; r++) {
          for (var g=0; g<grns.length; g++) {
            var red = sudokuCellsByPos[reds[r]];
            var grn = sudokuCellsByPos[grns[g]];
            var covis = coVisibleCells(red,grn);
            for (var c=0; c<covis.length; c++) {
              var cell = covis[c];
              if (cell[v]) {
                changes = changes + 1;
                cell[v] = false;
              }
            }
          }
        }
        return changes;
      }

      function getPathBetweenCells(links, start, end, ignore=[]) {
        var adjs = links[start];
        if (adjs.indexOf(end)>=0) {
          return [start, end];
        } else {
          for (var i=0; i<adjs.length; i++) {
            var next = adjs[i];
            if (ignore.indexOf(next)===-1) {
              var path = getPathBetweenCells(links,next,end,ignore.concat([start]));
              if (path) {
                return [start].concat(path);
              }
            }
          }
        }
        return false;
      }

      function partialApply2nd(fn, arg2) {
        return (function(arg1) {
          return fn(arg1, arg2);
        });
      }

      function simpleColors() {
        for (var v=0; v<9; v++)
          if (simpleColorsVal(v)) return true;
      }


      // Button actions.
      function buttonCall(solvingFunc, undoLabel=undefined) {
        if (undoLabel!==undefined) storeUndoState();
        if (solvingFunc()) {
          if (undoLabel!==undefined)
            saveStoredUndoState(undoLabel);
          refresh();
          return true;
        }
        return false;
      }

      function caButton() {
        buttonCall(clearAdjacents, "Clr Adjs");
      }

      function nsButton() {
        buttonCall(nakedSingles, "Nkd 1s");
      }

      function hsButton() {
        buttonCall(hiddenSingles, "Hdn 1s");
      }

      function irButton() {
        buttonCall(intersectionRemoval, "Intersect");
      }

      function npButton() {
        buttonCall(nakedPairs, "Nkd 2s");
      }

      function hpButton() {
        buttonCall(hiddenPairs, "Hdn 2s");
      }

      function ntButton() {
        buttonCall(nakedTriples, "Nkd 3s");
      }

      function htButton() {
        buttonCall(hiddenTriples, "Hdn 3s");
      }

      function nqButton() {
        buttonCall(nakedQuads, "Nkd 4s");
      }

      function xwButton() {
        buttonCall(XWings, "X-Wings");
      }

      function fxButton() {
        if (buttonCall(FinnedXWings))
          console.log("finned x-wings worked");
        else
          console.log("finned x-wings did not work");
      }

      function ywButton() {
        buttonCall(YWings, "Y-Wings");
      }

      function zwButton() {
        buttonCall(ZWings, "XYZ-Wings");
      }

      function sfButton() {
        buttonCall(swordfish, "Swordfish");
      }

      function scButton() {
        buttonCall(simpleColors, "Smpl Clrs");
      }

      function checkButton() {
        if (checkErrors()) {
          alert("some errors found :(");
        } else {
          alert("no errors found :)")
        }
      }


      function checkGroupForEmpties(group, desc) {
        var error = false;
        var counts = [0,0,0,0,0,0,0,0,0];
        // get the number of possibilities for each number in this group
        for (var c=0; c<9; c++) {
          var cell = group[c];
          if (isSolved(cell)) {
            counts[cell.solved]++;
          } else {
            for (var v=0; v<9; v++) {
              if (cell[v])
                counts[v]++;
            }
          }
        }

        // check if any are zero
        for (var v=0; v<9; v++) {
          if (counts[v] === 0) {
            consolelog("There can be no " + (v+1) + " in " + desc);
            error = true;
          }
        }
        return error;
      }

      function checkGroupForDuplicates(group, desc) {
        var error = false;
        var solveds = [false,false,false,false,false,false,false,false,false];
        for (var c=0; c<9; c++) {
          var cell = group[c];
          if (isSolved(cell)) {
            if (solveds[cell.solved-1]) {
              error = true;
              consolelog("Found two confirmed " + (cell.solved+1) + "s in " + desc);
            }
            solveds[cell.solved-1] = true;
          }
        }
        error = true;
      }

      function checkErrors() {
        var errors = false;
        // errors = checkGroupForEmpties(sudoku[0], "row " + (0+1)) || errors;
        for (var r=0; r<9; r++) {
          errors = checkGroupForDuplicates(sudoku[r], "row " + (r+1)) || errors;
          errors = checkGroupForEmpties(sudoku[r], "row " + (r+1)) || errors;
        }

        for (var c=0; c<9; c++) {
          errors = checkGroupForDuplicates(sudokuCols[c], "col " + (c+1)) || errors;
          errors = checkGroupForEmpties(sudokuCols[c], "col " + (c+1)) || errors;
        }

        for (var b=0; b<9; b++) {
          errors = checkGroupForDuplicates(sudokuBoxes[b], "box " + (b+1)) || errors;
          errors = checkGroupForEmpties(sudokuBoxes[b], "box " + (b+1)) || errors;
        }

        return errors;
      }


      function optionsConfined(group, otherGroupType) {
        var mins = [10, 10, 10, 10, 10, 10, 10, 10, 10];
        var maxs = [-1, -1, -1, -1, -1, -1, -1, -1, -1];

        // get the min and max value for grouptype (row/col/box) for
        // each cell holding each value.
        for (var c=0; c<9; c++) {
          var cell = group[c];
          for (var v=0; v<9; v++) {
            if (cell[v]) {
              mins[v] = Math.min(mins[v], cell[otherGroupType]);
              maxs[v] = Math.max(maxs[v], cell[otherGroupType]);
            }
          }
        }

        // when the min is the max, store that value in the below array.
        var totals = [-1, -1, -1, -1, -1, -1, -1, -1, -1];
        for (var v=0; v<9; v++) {
          if (mins[v] == maxs[v]) {
            totals[v] = mins[v];
          }
        }

        return totals;
      }

      function intersectionRemoval() {
        var changes = [];

        for (var i=0; i<9; i++) {
          var row = sudoku[i];
          var col = sudokuCols[i];
          var box = sudokuBoxes[i];

          var rowConfines    = optionsConfined(row, 'box');
          var colConfines    = optionsConfined(col, 'box');
          var boxConfinesRow = optionsConfined(box, 'row');
          var boxConfinesCol = optionsConfined(box, 'col');
          
          for (var v=0; v<9; v++) {
            if (rowConfines[v] >= 0) {
              // clear v from the box, apart from this row
              var intersectedBox = sudokuBoxes[rowConfines[v]];
              if (clearExceptGroup(intersectedBox, 'row', i, v)) {
                changes.push([row, intersectedBox, v]);
              }
            }
            if (colConfines[v] >= 0) {
              // clear v from the box, apart rom this col
              var intersectedBox = sudokuBoxes[colConfines[v]];
              if (clearExceptGroup(intersectedBox, 'col', i, v)) {
                changes.push([col, intersectedBox, v]);
              }
            }
            if (boxConfinesRow[v] >= 0) {
              // clear v from the row, apart from this box
              var intersectedRow = sudoku[boxConfinesRow[v]];
              if (clearExceptGroup(intersectedRow, 'box', i, v)) {
                changes.push([box, intersectedRow, v]);
              }
            }
            if (boxConfinesCol[v] >= 0) {
              // clear v from the col, apart from this box
              var intersectedCol = sudokuCols[boxConfinesCol[v]];
              if (clearExceptGroup(intersectedCol, 'box', i, v)) {
                changes.push([box, intersectedCol, v]);
              }
            }
          } 
        } 

        if (changes.length === 0) return false;
        for (var i=0; i<changes.length; i++) {
          var [group1,group2,v] = changes[i];
          consolelog("Intersection on value " + (v+1) + " between " + group1.groupName + " and " + group2.groupName + ".");
        }
        return true;

        // the below was existing alongside the above. not sure if it was needed or not...
        // // if all row options for N are in the same box, remove N from other cells in that box.
        // // same for col, and box->row.
        // for (var b=0; b<9; b++) {
        //   var box = sudokuBoxes[b];
        //   // in this box, look at every value's min/max positions.
        //   for (var v=0; v<9; v++) {
        //     var rMin = 10;
        //     var rMax = -1;
        //     var cMin = 10;
        //     var cMax = -1;
        //     for (var c=0; c<9; c++) {
        //       var cell = box[c];
        //       if (cell[v]) {
        //         rMin = Math.min(rMin, cell.row);
        //         rMax = Math.max(rMax, cell.row);
        //         cMin = Math.min(cMin, cell.col);
        //         cMax = Math.max(cMax, cell.col);
        //       }
        //     }
        //     if (rMin===rMax) {
        //       // in box b, value v is only found in row rMin
        //       // consolelog("clearing row " + (rMin+1) + " of " + (v+1) + " because of box " + (b+1));
        //       changed = clearExceptGroup(sudoku[rMin],'box',b,v) || changed;
        //     } else if (cMin===cMax) {
        //       // in box b, value v is only found in col cMin
        //       // consolelog("clearing col " + (cMin+1) + " of " + (v+1) + " because of box " + (b+1));
        //       changed = clearExceptGroup(sudokuCols[cMin],'box',b,v) || changed;
        //     }
        //   }
        // }
        // return changed;
      }

      function clearExceptGroup(thisgroup, othergrouptype, othergroup, v) {
        var changed = false;
        for (var i=0; i<9; i++) {
          var cell = thisgroup[i];
          if (cell[othergrouptype] !== othergroup) {
            if (cell[v]) {
              cell[v] = false;
              changed = true;
            }
          }
        }
        return changed;
      }

      function sameCell(cell1, cell2) {
        return (cell1.pos === cell2.pos);
      }

      function clearNakedPair(group, val1, val2, cell1, cell2) {
        var changed = false;
        for (var c=0; c<9; c++) {
          var cell = group[c];
          if (!sameCell(cell, cell1) && !sameCell(cell, cell2)) {
            changed = changed || cell[val1] || cell[val2];
            cell[val1] = false;
            cell[val2] = false;
          }
        }
        return changed;
      }

      function isNumber(v) {
        if (v === undefined) return false;
        if (v === null) return false;
        if (typeof v === "number") return true;
        return false;
      }

      function isSolved(cell) {
        return isNumber(cell.solved);
      }

      function clearAfterConfirm(cell) {
        var changed = false;
        if (isSolved(cell)) {
          var v = cell.solved;
          cell[v] = false;
          var row = sudoku[cell.row];
          var col = sudokuCols[cell.col];
          var box = sudokuBoxes[cell.box]
          for (var i=0; i<row.length; i++) {
            changed = changed || row[i][v] || col[i][v] || box[i][v];
            row[i][v] = false;
            col[i][v] = false;
            box[i][v] = false;
          }
        }
        return changed;
      }

      function confirmCell(cell, v) {
        var changed = !isSolved(cell) || v!==cell.solved;
        newCellsConfirmed.push(cell);
        for (var i=0; i<cell.length; i++) {
          cell[i] = false;
        }
        cell[v] = true;
        cell['solved'] = v;
        return changed;
      }

      function toggleCandidate(cell, v) {
        if (isSolved(cell)) return false;
        cell[v] = !cell[v];
        return true;
      }

      function autoButton() {
        saveUndoState("AUTOSOLVE");
        autoSolve();
      }

      function changeCell(cell) {
        var input = prompt("Enter the digits that are candidates for this cell. 0=all");
        if (input === null) return;
        if (input === "0") {
          cell['solved'] = undefined;
          for (var v=0; v<9; v++)
            cell[v] = true;
        } else if (input.length === 1) {
          var v = parseInt(input);
          cell['solved'] = v-1;
          for (var v=0; v<9; v++)
            cell[v] = false;
        } else if (input.length > 1) {
          cell['solved'] = undefined;
          for (var v=0; v<9; v++)
            cell[v] = false;
          for (var i=0; i<input.length; i++) {
            var v=parseInt(input.charAt(i));
            cell[v-1] = true;
          }
        }
        refresh();
      }

      function setDblClick(element, cell) {
        element.dblclick(function(){changeCell(cell)});
      }

      function undoButton() {
        undo();
      }

      function refreshUndoLog() {
        var labels = undoStack.map(d => d[0]).reverse();
        $("#history").html("History:<br>"+labels.join("<br>"));
      }

      function undo() {
        if (undoStack.length===0) {
          console.log("nothing to undo");
          return;
        }
        var [label, state] = undoStack.pop();
        console.log(`undoing "${label}"`);
        initSudokuData(state);
        refresh();
        refreshUndoLog();
      }

      function saveUndoState(label, state=getStatefulExportString()) {
        console.log(label);
        undoStack.push([label, state]);
        refreshUndoLog();
      }

      function zoneName(swatch) {
        if (swatch===undefined) return "none";
        switch (swatch) {
          case 0: return "blue";
          case 1: return "green 1";
          case 2: return "red";
          case 3: return "yellow";
          case 4: return "purple";
          case 5: return "organg";
          case 6: return "cyan";
          case 7: return "green 2";
          case 8: return "pink";
        }
      }

      var tempUndoState = "";
      function storeUndoState() {
        tempUndoState = getStatefulExportString();
      }

      function saveStoredUndoState(label) {
        saveUndoState(label, tempUndoState);
      }

      function setCellClick(td, cell) {
        // td.off("click").click(function(){
        //   if (inputState===SETNOTHING) return;
        //   if (inputNum===undefined) return;

        //   if (inputState===SETFULL) {
        //     storeUndoState();
        //     if (confirmCell(cell, inputNum))
        //       saveStoredUndoState(cell.pos + " = " + (inputNum+1));
        //     if ($("#autoclearadjs").prop('checked')) {
        //       clearAfterConfirm(cell);
        //     }
        //     refresh();
        //   }
        //   if (inputState===SETCAND) {
        //     storeUndoState();
        //     if (toggleCandidate(cell, inputNum)) {
        //       var plusminus = cell[inputNum] ? '+' : '-';
        //       saveStoredUndoState(cell.pos+" "+plusminus+" "+(inputNum+1));
        //       refresh();
        //     }
        //   }
        //   if (inputState===SETCOLOR) {
        //     if (cell.swatch === inputNum) {
        //       saveUndoState(cell.pos+" blank");
        //       cell.swatch = undefined;
        //     } else {
        //       saveUndoState(cell.pos+" "+zoneName(inputNum));
        //       cell.swatch = inputNum;
        //     }
        //     refreshHighlights();
        //   }
        // });

        td.off("mousedown").on("mousedown", function(){
          if (inputState===SETNOTHING) return;
          if (inputState===undefined) return;
          
          // confirm the cell
          if (inputState===SETFULL) {
            storeUndoState();
            if (confirmCell(cell, inputNum))
              saveStoredUndoState(cell.pos + " = " + (inputNum+1));
            if ($("#autoclearadjs").prop('checked')) {
              clearAfterConfirm(cell);
            }
            refresh();
            return;
          }

          // toggle the cell
          if (inputState === SETCAND) {
            storeUndoState();
            if (toggleCandidate(cell, inputNum)) {
              var plusminus = cell[inputNum] ? '+' : '-';
              saveStoredUndoState(cell.pos+" "+plusminus+" "+(inputNum+1));
              refresh();
            }
            return;
          }

          // set the color
          if (inputState===SETCOLOR) {
            if (cell.swatch === inputNum) {
              saveUndoState(cell.pos+" blank");
              cell.swatch = undefined;
              dragState = -1; // CLEARING COLOURS
            } else {
              saveUndoState(cell.pos+" "+zoneName(inputNum));
              cell.swatch = inputNum;
              dragState = inputNum; // SPREADING THIS COLOR
            }
            refreshHighlights();
          }
        });

        td.off("mouseenter").on("mouseenter", function(e){
          if (dragState === undefined) return;
          if (dragState === -1 && cell.swatch !== undefined) {
            saveUndoState(cell.pos+" blank");
            cell.swatch = undefined;
          } else if (dragState >= 0 && dragState <= 8) {
            if (cell.swatch !== dragState) {
              saveUndoState(cell.pos+" "+zoneName(dragState));
              cell.swatch = dragState;
            }
          }
          refreshHighlights();
        });
      }

      function buildTable(data) {
        var table = $("#tbl");
        table.empty();
        for (var r=0; r<data.length; r++) {
          var tr = $("<tr>").addClass("row");
          for (var c=0; c<data[r].length; c++) {
            var cell = data[r][c];
            var td = $("<td>").addClass("cell");
            td.attr('id', cell.pos);
            cell['td'] = td;
            // setDblClick(td,cell);
            setCellClick(td,cell);
            if(isSolved(cell)) {
              td.append($("<c"+(cell.solved+1)+">"));
            } else {
              for (var i=0; i<cell.length; i++) {
                if (cell[i])
                  td.append($("<v"+(i+1)+">"));
              }
            }
            tr.append(td);
          }
          table.append(tr);
        }
        for (var i=0; i<=10; i++) {
          $("v"+i).text(i);
          $("c"+i).text(i);
        }
      }

      function initSudoku(data) {
        if (data) initSudokuData(data);
        else initSudokuBlank();
      }

      function boxNum(r, c) {
        if (r<3) {
          if (c<3) return 0;
          if (c<6) return 1;
          if (c<9) return 2;
        } else if (r<6) {
          if (c<3) return 3;
          if (c<6) return 4;
          if (c<9) return 5;
        } else if (r<9) {
          if (c<3) return 6;
          if (c<6) return 7;
          if (c<9) return 8;
        } else return -1;
      }

      function initSudokuBlank() {
        // init lists to zero
        sudoku = [];
        sudokuCols = [];
        sudokuBoxes = [];
        sudokuCellsByPos = [];
        newCellsConfirmed = [];

        // fill lists with empty lists
        for(var i=0; i<9; i++) {
          sudoku.push([]);
          sudokuCols.push([]);
          sudokuBoxes.push([]);
        }
        for (var i=0; i<9; i++) {
          sudoku[i].groupName = "Row " + (i+1);
          sudoku[i].groupType = "row";
          sudokuCols[i].groupName = "Col " + (i+1);
          sudokuCols[i].groupType = "col";
          sudokuBoxes[i].groupName = "Box " + (i+1);
          sudokuBoxes[i].groupType = "box";
        }

        // make all cells
        for (var c=0; c<9; c++) {
          for(var r=0; r<9; r++) {
            var b = boxNum(r,c);

            // make the cell and fill it with 'true'
            var cell = [];
            for (var v=0; v<9; v++) {
              cell.push(true);
            }
            // record its position on the board
            cell['row'] = r;
            cell['col'] = c;
            cell['box'] = b;
            cell['pos'] = "R" + (r+1) + "C" + (c+1);

            // add it to the lists
            sudoku[r][c] = cell;
            sudokuCols[c][r] = cell;
            sudokuBoxes[b].push(cell);
            sudokuCellsByPos[cell.pos] = cell;
          }
        }
      }

      function makeEmptyCell() {
        var out = [];
        for (var i=1; i<=9; i++)
          out[i] = true;
        return out;
      }
      
      function makeKnownCell(v) {
        var out = [];
        for (var i=1; i<=9; i++)
          out[i] = false;
        out[v-1] = true;
        out['solved'] = v;
        return out;
      }

      const statefulRegexp = /^[1-9]*[A-I]?(,[1-9]*[A-I]?)+$/
      const regularRegexp  = /^[0-9]+$/
      function initSudokuData(data) {
        initSudokuBlank();
        if (typeof data !== "string") return;

        if (data.match(regularRegexp)) {
          for (var i=0; i<data.length; i++) {
            var r = Math.floor(i/9);
            var c = i % 9;
            var ch = parseInt(data.charAt(i));
            if (ch > 0)
              confirmCell(sudoku[r][c], ch-1);
          }
        } else if (data.match(statefulRegexp)) {
          data = data.split(',');
          for (var i=0; i<data.length; i++) {
            var r = Math.floor(i/9);
            var c = i % 9;
            setCellFromState(sudoku[r][c], data[i]);
          }
        }
      }
      const candsAndSwatch = /^[1-9]*[A-I]$/
      function setCellFromState(cell, data) {
        var swatch = '';
        var cands = '';
        if (data.match(candsAndSwatch)) {
          swatch = data.substring(data.length-1);
          cands = data.substring(0,data.length-1);
        } else {
          cands = data;
        }
        cell.swatch = swatchFromChar(swatch);
        if (cands.length===1) {
          var v = parseInt(cands);
          confirmCell(cell,v-1)
        } else {
          for (var i=0; i<9; i++) cell[i]=false;
          for (var i=0; i<cands.length; i++) {
            var v = parseInt(cands[i])-1;
            cell[v] = true;
          }
        }
      }

      function importButton() {
        var input = "" + prompt("Enter 81 digits, like \"0814\"... 0 means unknown. Alternatively, enter a stateful export string provided by this app (containing commas and letters)");
        initSudoku(input);
        refresh();
      }

      function getExportString() {
        var output = "";
        for (var r=0; r<9; r++) {
          for (var c=0; c<9; c++) {
            var cell = sudoku[r][c];
            if (isSolved(cell)) {
              output = output + (cell.solved+1);
            } else {
              output = output + "0";
            }
          }
        }
        return output;
      }

      function charFromSwatch(val) {
        if (val===undefined) return '';
        return String.fromCharCode(65+val);
      }

      function swatchFromChar(char) {
        if (char==='') return undefined;
        if (char < 'A') return undefined;
        if (char > 'I') return undefined;
        return char.charCodeAt(0)-65;
      }

      function getStatefulExportString() {
        var output = [];
        for (var r=0; r<9; r++) {
          for (var c=0; c<9; c++) {
            var cell = sudoku[r][c];
            var cellstring = "";
            if (isSolved(cell)) {
              cellstring = ""+(cell.solved+1);
            } else {
              for (var v=0; v<9; v++) {
                if (cell[v]) {
                  cellstring = cellstring + (v+1);
                }
              }
            }
            cellstring = cellstring + charFromSwatch(cell.swatch);
            output.push(cellstring);
          }
        }
        return output.join(",");
      }

      // briefly flash the button given by "id".
      function flashButton(id) {
        var btn = $("button#"+id);
        btn.removeClass("highlight").addClass("highlight");
        setTimeout(function(){
          btn.removeClass("highlight");
        }, flashDelay);
      }

      function exportButton() {
        var output = getExportString();
        $("#exportfield").val(output);
      }

      function statefulExportButton() {
        var output = getStatefulExportString();
        $("#exportfield").val(output);
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split("&");
        for (var i=0;i<vars.length;i++) {
          var pair = vars[i].split("=");
          if(pair[0] == variable) {
            return pair[1];
          }
        }
        return false;
      }

      // if a test file is loaded, parse all sudokus in it and attempt to complete them.
      function testFileLoaded() {
        var total      = 0;
        var finished   = 0;
        var incomplete = 0;
        var errors     = 0;

        console.log("Total / Completed / Incomplete / Errors");
        logging = false;
        var file = $("#testFile")[0].files[0];
        new LineReader(file).readLines(function(line){
          var [givens, solution] = line.split(",");
          if (total%1000===0) {
            console.log([total, finished, incomplete, errors].join(" / "));
            refresh();
          }
          total = total + 1;
          var myOutput = completeSilently(givens);
          if (myOutput === solution) {
            finished = finished + 1;
          } else if ("myOutput"==="INCOMPLETE") {
            incomplete = incomplete + 1;
          } else if ("myOutput"==="ERROR") {
            errors = errors + 1;
          }
        }, function(){
          console.log(total + " sudokus attempted.");
          console.log(finished +" solved correctly.");
          console.log(incomplete +" incomplete.");
          console.log(errors+" resulted in errors.");
          logging = true;
          refresh();
        });
      }

      $(document).ready(onReady);
    </script>
  </head>
  <body>
    <button onclick="javascript:autoButton();">SOLVE</button>
    <button id="caButton" onclick="javascript:caButton();">Clear Adjacents</button>
    <button id="nsButton" onclick="javascript:nsButton();">Naked Singles</button>
    <button id="hsButton" onclick="javascript:hsButton();">Hidden Singles</button>
    <button id="npButton" onclick="javascript:npButton();">Naked Pairs</button>
    <button id="hpButton" onclick="javascript:hpButton();">Hidden Pairs</button>
    <button id="ntButton" onclick="javascript:ntButton();">Naked Triples</button>
    <button id="htButton" onclick="javascript:htButton();">Hidden Triples</button>
    <button id="htButton" onclick="javascript:nqButton();">Naked Quads</button>
    <button id="irButton" onclick="javascript:irButton();">Intersection Removal</button>
    <button id="xwButton" onclick="javascript:xwButton();">X-Wings</button>
    <button id="ywButton" onclick="javascript:ywButton();">Y-Wings</button>
    <button id="zwButton" onclick="javascript:zwButton();">Z-Wings</button>
    <button id="sfButton" onclick="javascript:sfButton();">Swordfish</button>
    <button id="fxButton" onclick="javascript:fxButton();">Finned X-Wings</button>
    <button id="scButton" onclick="javascript:scButton();">Simple Coloring</button>
    <div id="gamewrapper">
      <div id="history"></div>
      <table id="tbl" class="noselect"></table>
      <div id="ctrl">
        <table id="confirm">
          <tr><td>1</td><td>2</td><td>3</td></tr>
          <tr><td>4</td><td>5</td><td>6</td></tr>
          <tr><td>7</td><td>8</td><td>9</td></tr>
        </table><br/><br/>
        <table id="candidate">
          <tr><td>1</td><td>2</td><td>3</td></tr>
          <tr><td>4</td><td>5</td><td>6</td></tr>
          <tr><td>7</td><td>8</td><td>9</td></tr>
        </table>
        <br/>
        <input id="autoclearadjs" type="checkbox" checked>Auto-clear adjs</input>
        <br/><br/>
        <table id="swatches">
          <tr><td></td><td></td><td></td></tr>
          <tr><td></td><td></td><td></td></tr>
          <tr><td></td><td></td><td></td></tr>
        </table>
      </div>
    </div>
    <button onclick="javascript:importButton();">Import</button>
    <button onclick="javascript:exportButton();">Export</button>
    <button onclick="javascript:statefulExportButton();">Full Export</button>
    <input type="text" id="exportfield"></input>
    Testing Dataset: <input type="file" id="testFile" onchange="javascript:testFileLoaded();"/>
    <button id="undobutton" onclick="javascript:undoButton();">UNDO</button>
    <button onclick="javascript:checkButton();">Check Errors</button>
    <button onclick="javascript:onReady();">Reset</button>
  </body>
</html>