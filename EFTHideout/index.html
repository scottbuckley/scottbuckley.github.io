
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8" />
<title>Hideout D3 Cola</title>
<link rel="stylesheet" type="text/css" href="font/MyFontsWebfontsKit.css">
<style>

.hex {
  stroke: #fff;
  fill: black;
  stroke-width: 0.5px;
  opacity:0.6;
}

.built {
  fill:green;
}

.nodeCover {
  fill: #ffffff00;
  stroke: none;
  stroke-width:2px;
}

.nodeCover.selected {
  stroke:black;
  opacity:50%;
}

.path {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
  opacity: 0.5;
  marker-end:url(#end-arrow-normal);
}

.path.red {
  stroke: red;
  marker-end:url(#end-arrow-red);
}

.path.green {
  stroke: green;
  marker-end:url(#end-arrow-green);
}

marker#end-arrow-red {
  fill:red;
  stroke:red;
}

marker#end-arrow-green {
  fill:green;
  stroke:green;
}

.level {
    fill: black;
    font-family: Bender-Black;
    font-size: 20px;
    fill:#FFF;
    stroke:#000;
    stroke-width:1px;
    letter-spacing:-2.5px;
    text-anchor: middle;
    alignment-baseline: central;
}

.image {
    fill: black;
    font-family: Verdana;
    font-size: 5px;
    text-anchor: middle;
    cursor: move;
}

</style>
</head>
<body>
  <script src="d3.v4.min.js"></script>
  <script src="cola.min.js"></script>
  <script>
    var width = window.document.documentElement.clientWidth-50,
        height = window.document.documentElement.clientHeight;

    var nodeRadius = 30;
    var nodeSpacing = 90;

    var store = window.localStorage;

    var color = d3.scaleOrdinal(d3.schemeCategory20);


    var d3cola = cola.d3adaptor(d3)
        .avoidOverlaps(true)
        .size([width, height]);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);


    var processNamedLinks = function(graph) {
      graph.dict = [];
      graph.nodes.forEach(function (n, i) {
        graph.dict[n.id] = i;
      });

      graph.links = [];
      graph.namedlinks.forEach(function(l){
        var newlink = {...l}; // clone the link
        newlink.source = graph.dict[l.source];
        newlink.target = graph.dict[l.target];
        graph.links.push(newlink);
      });
    };

    d3.json("hideout2.json", function (error, graph) {
        
        processNamedLinks(graph);

        //preprocess nodes
        graph.nodes.forEach(function (n,i) {
          n.height = n.width = nodeRadius*2.5;
          n.index=i;
          n.built = (store[`built_${n.id}`]==="true");
        });

        graph.links.forEach(function(l,i) {
          l.linkIndex = i;
        });

        d3cola
            .nodes(graph.nodes)
            .links(graph.links)
            .flowLayout("y", nodeRadius*2.5)
            .symmetricDiffLinkLengths(18)
            // .linkDistance(nodeSpacing)
            .start(10,20,20);


        //define a few markers
        svg.append('svg:defs').selectAll('marker')
           .data(['normal', 'red', 'green']).enter()
           .append('svg:marker')
           .attr('id', (t)=>`end-arrow-${t}`)
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 6)
            .attr('markerWidth', 3)
            .attr('markerHeight', 3)
            .attr('orient', 'auto')
          .append('svg:path')
            .attr('d', 'M0,-5L10,0L0,5');



        var paths = svg.selectAll(".path")
            .data(graph.links)
          .enter().append('svg:path')
            .attr('class', 'path');

        var normalHex = "-8.6 -5,0 -10,8.6 -5,8.6 5,0 10,-8.6 5";
        var biggerHex = "-13 -7.5,0 -15,13 -7.5,13 7.5,0 15,-13 7.5";

        var hexes = svg.selectAll(".hex")
            .data(graph.nodes)
          .enter()
          .append("polygon")
            .attr("class", "hex")
            .attr("id", (d)=>`hex${d.id}`)
            .attr("points", normalHex)
            .classed("built", (d)=>d.built)
            // .attr("fill", (d, i) => d3.hsl(color(d.group)).darker(2))
            .call(d3cola.drag);

        var getIcon = function(n) {
          return `icons/${n.type}.png`;
        };

        var prettyNodeName = function(n) {
          return `${n.type} Level ${n.level}`;
        }

        var images = svg.selectAll(".image")
            .data(graph.nodes)
            .enter().append("image")
            .attr("xlink:href", getIcon)
            .attr("x", function(d) { return -25;})
            .attr("y", function(d) { return -25;})
            .attr("height", 50)
            .attr("width", 50);

        var levels = svg.selectAll(".level")
            .data(graph.nodes)
            .enter().append("text").text((n) => "0"+n.level)
            .attr("class", "level")
            .call(d3cola.drag);

        // an invisible hexagon over the node, which handles all kinds of interaction.
        var covers = svg.selectAll(".nodeCover")
          .data(graph.nodes)
          .enter()
          .append("polygon")
            .attr("class", "nodeCover")
            .attr("points", normalHex)
            .attr("graphIndex", (d, i) => i)
            .on("mouseover", mouseover)
            .on("mouseout", mouseout)
            .on("click", nodeClick)
            .on("dblclick", nodeDblClick)
            .call(d3cola.drag);
        
        d3.select("body")
            .on("click", outsideClick)
            .on("keydown", keyDown);
        
        // give every hex a link to its nodeCover
        hexes.each((n, i) => {
          var hex = d3.select(`polygon#hex${n.id}`);
          n.hex = hex;
        });

        // hover titles for nodes, images, levels
        covers.append("title").text(prettyNodeName);



        function updateNodeDisplays() {
          
          if (sel = getSelectedNode) {

            paths.classed("red",   (l) => l.target.selected && !l.source.built);
            paths.classed("green", (l) => l.target.selected &&  l.source.built);

            // paths.each(function(l){
            //   if (l.target.selected) {
            //     console.log(l.source.id);
            //     this.attr("stroke", "red");
            //   }
            // });
          }

          hexes.each(function(n) {
            // console.log(this);
            // console.log(n);
          });
        }

        function updateBuiltStatus() {
          hexes.classed("built", (n) => n.built);
        }

        function nodeDblClick(n) {
        //   n.built = !n.built;
        

        //   var hex = d3.select(`polygon#hex${n.id}`);
        //   hex.classed("built", n.built);
        }

        function setSelected(b) {
          return function(n) {
            n.selected = b; return b;
          }
        }

        function nodeClick(n) {
          // this click shouldn't also register on the background
          d3.event.stopPropagation();

          var thisCover = d3.select(this);
          if (thisCover.classed("selected")) {
            // already selected. unselect
            thisCover.classed("selected", setSelected(false));
          } else {
            // not selected. unselect everything else and select this.
            covers.classed("selected", setSelected(false));
            thisCover.classed("selected", setSelected(true));
          }
          updateNodeDisplays();
        }

        function outsideClick() {
          covers.classed("selected", setSelected(false));
          updateNodeDisplays();
        }


        function getSelectedNode() {
          for (var i=0; i<graph.nodes.length; i++) {
            if (graph.nodes[i].selected) return graph.nodes[i];
          }
        }


        function toggleBuilt(n) {
          n.built = !n.built;
          store[`built_${n.id}`] = n.built;
        }

        function keyDown(e) {
          if (event.keyCode="KeyB") {
            if (n = getSelectedNode()) {
              toggleBuilt(n);
              updateBuiltStatus();
            }
          }
        }
        

        function mouseover(n) {
          d3.select(`polygon#hex${n.id}`)
            .transition()
            .duration(250)
            .style("opacity", 0.3)
            .attr("points", biggerHex);
        }

        function mouseout(n) {
          d3.select(`polygon#hex${n.id}`)
            .transition()
            .duration(250)
            .style("opacity", 0.6)
            .attr("points", normalHex);
        }

        function tick() {

          // draw directed edges with proper padding from node centers
          paths.attr('d', function (d) {
                var deltaX = d.target.x - d.source.x,
                    deltaY = d.target.y - d.source.y,
                    dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
                    normX = deltaX / dist,
                    normY = deltaY / dist,
                    sourcePadding = nodeRadius,
                    targetPadding = nodeRadius + 2,
                    sourceX = d.source.x + (sourcePadding * normX),
                    sourceY = d.source.y + (sourcePadding * normY),
                    targetX = d.target.x - (targetPadding * normX),
                    targetY = d.target.y - (targetPadding * normY);
                return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
            });

            var hexScale = nodeRadius/10;
            hexes.attr("transform", function (d) {
                return `translate(${d.x}, ${d.y}) scale(${hexScale})`;
            });

            covers.attr("transform", function (d) {
                return `translate(${d.x}, ${d.y}) scale(${hexScale})`;
            });

            levels.attr("transform", function (d) {
                return `translate(${d.x+nodeRadius*0.5}, ${d.y+nodeRadius*0.5}) scale(${hexScale/3})`;
            });

            images.attr("transform", function (d) {
                return `translate(${d.x}, ${d.y}) scale(${hexScale/4})`;
            });
        }

        d3cola.on("tick", tick);
    });

</script>
</body>
</html>
