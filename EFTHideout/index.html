
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8" />
<title>Hideout D3 Cola</title>
<link rel="stylesheet" type="text/css" href="font/MyFontsWebfontsKit.css">
<style>

.hex {
  stroke: #fff;
  fill: black;
  stroke-width: 0.5px;
  opacity:0.6;
}

.built {
  fill:green;
}

.nodeCover {
  fill: #ffffff00;
  stroke: none;
  stroke-width:2px;
}

.nodeCover.selected {
  stroke:black;
  opacity:50%;
}

.link {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
  opacity: 0.5;
  marker-end: url(#end-arrow);
}

.level {
    fill: black;
    font-family: Bender-Black;
    font-size: 20px;
    fill:#FFF;
    stroke:#000;
    stroke-width:1px;
    letter-spacing:-2.5px;
    text-anchor: middle;
    alignment-baseline: central;
}

.image {
    fill: black;
    font-family: Verdana;
    font-size: 5px;
    text-anchor: middle;
    cursor: move;
}

</style>
</head>
<body>
  <script src="d3.v4.min.js"></script>
  <script src="cola.min.js"></script>
  <script>
    var width = window.document.documentElement.clientWidth-50,
        height = window.document.documentElement.clientHeight;

    var nodeRadius = 30;
    var nodeSpacing = 90;

    var store = window.localStorage;

    var color = d3.scaleOrdinal(d3.schemeCategory20);


    var d3cola = cola.d3adaptor(d3)
        .avoidOverlaps(true)
        .size([width, height]);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);


    var processNamedLinks = function(graph) {
      graph.dict = [];
      graph.nodes.forEach(function (n, i) {
        graph.dict[n.id] = i;
      });

      graph.links = [];
      graph.namedlinks.forEach(function(l){
        var newlink = {...l}; // clone the link
        newlink.source = graph.dict[l.source];
        newlink.target = graph.dict[l.target];
        graph.links.push(newlink);
      });
    };

    d3.json("hideout2.json", function (error, graph) {
        
        processNamedLinks(graph);

        //preprocess nodes
        graph.nodes.forEach(function (n,i) {
          n.height = n.width = nodeRadius*2.5;
          n.index=i;
          n.built = (store[`built_${n.id}`]==="true");
        });

        d3cola
            .nodes(graph.nodes)
            .links(graph.links)
            .flowLayout("y", nodeRadius*2.5)
            .symmetricDiffLinkLengths(18)
            // .linkDistance(nodeSpacing)
            .start(10,20,20);

        // define arrow markers for graph links
        svg.append('svg:defs').append('svg:marker')
            .attr('id', 'end-arrow')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 6)
            .attr('markerWidth', 3)
            .attr('markerHeight', 3)
            .attr('orient', 'auto')
          .append('svg:path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#000');

        var path = svg.selectAll(".link")
            .data(graph.links)
          .enter().append('svg:path')
            .attr('class', 'link');

        var normalHex = "-8.6 -5,0 -10,8.6 -5,8.6 5,0 10,-8.6 5";
        var biggerHex = "-13 -7.5,0 -15,13 -7.5,13 7.5,0 15,-13 7.5";

        var hex = svg.selectAll(".hex")
            .data(graph.nodes)
          .enter()
          .append("polygon")
            .attr("class", "hex")
            .attr("id", (d)=>`hex${d.id}`)
            .attr("points", normalHex)
            .classed("built", (d)=>d.built)
            // .attr("fill", (d, i) => d3.hsl(color(d.group)).darker(2))
            .call(d3cola.drag);

        var getIcon = function(n) {
          return `icons/${n.type}.png`;
        };

        var prettyNodeName = function(n) {
          return `${n.type} Level ${n.level}`;
        }

        var images = svg.selectAll(".image")
            .data(graph.nodes)
            .enter().append("image")
            .attr("xlink:href", getIcon)
            .attr("x", function(d) { return -25;})
            .attr("y", function(d) { return -25;})
            .attr("height", 50)
            .attr("width", 50);

        var level = svg.selectAll(".level")
            .data(graph.nodes)
            .enter().append("text").text((n) => "0"+n.level)
            .attr("class", "level")
            .call(d3cola.drag);

        // an invisible hexagon over the node, which handles all kinds of interaction.
        var nodeCover = svg.selectAll(".nodeCover")
          .data(graph.nodes)
          .enter()
          .append("polygon")
            .attr("class", "nodeCover")
            .attr("points", normalHex)
            .attr("graphIndex", (d, i) => i)
            .on("mouseover", mouseover)
            .on("mouseout", mouseout)
            .on("click", nodeClick)
            .on("dblclick", nodeDblClick)
            .call(d3cola.drag);
        
        d3.select("body").on("click", outsideClick);
        
        // give every hex a link to its nodeCover
        hex.each((n, i) => {
          var cover = d3.select(`polygon#hex${n.id}`);
          n.cover = cover;
        });

        // hover titles for nodes, images, levels
        nodeCover.append("title").text(prettyNodeName);



        function updateNodeDisplays() {
          hex.each(function(n) {
            // console.log(this);
            // console.log(n);
          });
        }

        function nodeDblClick(n) {
          n.built = !n.built;
          store[`built_${n.id}`] = n.built;

          var hex = d3.select(`polygon#hex${n.id}`);
          hex.classed("built", n.built);
        }

        function nodeClick(n) {
          // this click shouldn't also register on the background
          d3.event.stopPropagation();

          var cover = d3.select(this);
          if (cover.classed("selected")) {
            // already selected. unselect
            cover.classed("selected", false);
          } else {
            // not selected. unselect everything else and select this.
            nodeCover.classed("selected", false);
            cover.classed("selected", true);
          }
          return true;
        }

        function outsideClick() {
          nodeCover.classed("selected", false);
        }

        function mouseover(n) {
          d3.select(`polygon#hex${n.id}`)
            .transition()
            .duration(250)
            .style("opacity", 0.3)
            .attr("points", biggerHex);
        }

        function mouseout(n) {
          d3.select(`polygon#hex${n.id}`)
            .transition()
            .duration(250)
            .style("opacity", 0.6)
            .attr("points", normalHex);
        }

        function tick() {

          // draw directed edges with proper padding from node centers
          path.attr('d', function (d) {
                var deltaX = d.target.x - d.source.x,
                    deltaY = d.target.y - d.source.y,
                    dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
                    normX = deltaX / dist,
                    normY = deltaY / dist,
                    sourcePadding = nodeRadius,
                    targetPadding = nodeRadius + 2,
                    sourceX = d.source.x + (sourcePadding * normX),
                    sourceY = d.source.y + (sourcePadding * normY),
                    targetX = d.target.x - (targetPadding * normX),
                    targetY = d.target.y - (targetPadding * normY);
                return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
            });

            var hexScale = nodeRadius/10;
            hex.attr("transform", function (d) {
                return `translate(${d.x}, ${d.y}) scale(${hexScale})`;
            });

            nodeCover.attr("transform", function (d) {
                return `translate(${d.x}, ${d.y}) scale(${hexScale})`;
            });

            level.attr("transform", function (d) {
                return `translate(${d.x+nodeRadius*0.5}, ${d.y+nodeRadius*0.5}) scale(${hexScale/3})`;
            });

            images.attr("transform", function (d) {
                return `translate(${d.x}, ${d.y}) scale(${hexScale/4})`;
            });
        }

        d3cola.on("tick", tick);
    });

</script>
</body>
</html>
